<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Controller</title>
        <link
            href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap"
            rel="stylesheet"
        />
        <style>
            :root {
                --bg: #000;
                --fg: #00ffd5;
                --dim: rgba(0, 255, 213, 0.2);
            }
            body {
                background: var(--bg);
                color: var(--fg);
                font-family: "Orbitron", sans-serif;
                margin: 0;
                padding: 0;
                height: 100vh;
                overflow: hidden;
            }
            #topbar {
                height: 56px;
                display: flex;
                align-items: center;
                justify-content: space-between;
                padding: 0 16px;
                border-bottom: 1px solid var(--dim);
            }
            #brand {
                font-weight: 700;
                letter-spacing: 0.15em;
            }
            #toggle {
                background: transparent;
                border: 2px solid var(--fg);
                color: var(--fg);
                padding: 10px 14px;
                font-size: 14px;
                border-radius: 10px;
                cursor: pointer;
                transition:
                    background 0.2s,
                    box-shadow 0.2s;
            }
            #toggle:hover {
                background: var(--dim);
                box-shadow: 0 0 10px var(--fg);
            }
            #content {
                height: calc(100vh - 56px);
            }
            #viewer {
                width: 100%;
                height: 100%;
                border: 0;
                background: #050505;
            }
        </style>
    </head>

    <body>
        <div id="topbar">
            <div id="brand">GERVIS</div>
            <button id="toggle">Mic On</button>
        </div>

        <div id="content">
            <iframe id="viewer" src="about:blank"></iframe>
        </div>

        <script>
            const sampleRate = 24000;
            const channelCount = 1;

            let ws;
            let audioCtx;
            let micStream;
            let workletNode;
            let isRecording = false;

            const toggleBtn = document.getElementById("toggle");
            const viewer = document.getElementById("viewer");

            // playback
            let playbackCursor = 0;
            let playbackQueue = [];
            let schedulerRunning = false;

            // outgoing buffering
            const BUFFER_SIZE = 256 * 6; // 1536 bytes
            let outgoingBuffer = new Int16Array(BUFFER_SIZE / 2);
            let outgoingOffset = 0;

            const recorderWorkletUrl = URL.createObjectURL(
                new Blob(
                    [
                        `
            class RecorderProcessor extends AudioWorkletProcessor {
              process(inputs) {
                const input = inputs[0][0];
                if (input) {
                  const int16Buffer = new Int16Array(input.length);
                  for (let i = 0; i < input.length; i++) {
                    let s = Math.max(-1, Math.min(1, input[i]));
                    int16Buffer[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
                  }
                  this.port.postMessage(int16Buffer.buffer, [int16Buffer.buffer]);
                }
                return true;
              }
            }
            registerProcessor('recorder-processor', RecorderProcessor);
          `,
                    ],
                    { type: "application/javascript" },
                ),
            );

            async function loadConfig() {
                const res = await fetch("/config.json");
                const cfg = await res.json();
                if (cfg && cfg.rerun_url) viewer.src = cfg.rerun_url;
            }

            function scheduleNext() {
                if (!schedulerRunning) return;
                if (!playbackQueue.length) {
                    setTimeout(scheduleNext, 20);
                    return;
                }

                const floatBuffer = playbackQueue.shift();
                const audioBuffer = audioCtx.createBuffer(
                    channelCount,
                    floatBuffer.length,
                    sampleRate,
                );
                audioBuffer.copyToChannel(floatBuffer, 0);

                const src = audioCtx.createBufferSource();
                src.buffer = audioBuffer;
                src.connect(audioCtx.destination);

                const now = audioCtx.currentTime;
                if (playbackCursor < now + 0.05) playbackCursor = now + 0.05;

                const duration = floatBuffer.length / sampleRate;
                src.start(playbackCursor);
                playbackCursor += duration;

                setTimeout(scheduleNext, 10);
            }

            async function startRecording() {
                if (ws) return;

                await loadConfig();

                audioCtx = new (window.AudioContext ||
                    window.webkitAudioContext)({ sampleRate });
                playbackCursor = 0;

                const protocol = location.protocol === "https:" ? "wss" : "ws";
                ws = new WebSocket(`${protocol}://${location.host}/ws`);
                ws.binaryType = "arraybuffer";

                ws.onmessage = (event) => {
                    if (!(event.data instanceof ArrayBuffer)) return;
                    const int16Buffer = new Int16Array(event.data);
                    const floatBuffer = new Float32Array(int16Buffer.length);
                    for (let i = 0; i < int16Buffer.length; i++)
                        floatBuffer[i] = int16Buffer[i] / 32768;
                    playbackQueue.push(floatBuffer);

                    if (!schedulerRunning) {
                        schedulerRunning = true;
                        scheduleNext();
                    }
                };

                micStream = await navigator.mediaDevices.getUserMedia({
                    audio: { channelCount, sampleRate },
                });
                const source = audioCtx.createMediaStreamSource(micStream);

                await audioCtx.audioWorklet.addModule(recorderWorkletUrl);
                workletNode = new AudioWorkletNode(
                    audioCtx,
                    "recorder-processor",
                    {
                        numberOfInputs: 1,
                        numberOfOutputs: 0,
                        channelCount,
                    },
                );

                outgoingOffset = 0;

                workletNode.port.onmessage = (e) => {
                    if (!ws || ws.readyState !== WebSocket.OPEN) return;
                    const chunk = new Int16Array(e.data);

                    let i = 0;
                    while (i < chunk.length) {
                        const space = outgoingBuffer.length - outgoingOffset;
                        const toCopy = Math.min(space, chunk.length - i);
                        outgoingBuffer.set(
                            chunk.subarray(i, i + toCopy),
                            outgoingOffset,
                        );
                        outgoingOffset += toCopy;
                        i += toCopy;

                        if (outgoingOffset === outgoingBuffer.length) {
                            ws.send(outgoingBuffer.buffer.slice(0));
                            outgoingOffset = 0;
                        }
                    }
                };

                source.connect(workletNode);

                isRecording = true;
                toggleBtn.textContent = "Mic Off";
            }

            function stopRecording() {
                if (!ws) return;

                if (outgoingOffset > 0 && ws.readyState === WebSocket.OPEN) {
                    ws.send(outgoingBuffer.buffer.slice(0, outgoingOffset * 2));
                    outgoingOffset = 0;
                }

                if (workletNode) {
                    workletNode.disconnect();
                    workletNode = null;
                }

                if (micStream) {
                    micStream.getTracks().forEach((t) => t.stop());
                    micStream = null;
                }

                ws.close();
                ws = null;

                playbackCursor = 0;
                schedulerRunning = false;
                playbackQueue = [];

                isRecording = false;
                toggleBtn.textContent = "Mic On";
            }

            toggleBtn.onclick = async () => {
                if (!isRecording) await startRecording();
                else stopRecording();
            };

            loadConfig();
        </script>
    </body>
</html>
